---
sidebar_position: 5
slug: /layouts
---

import AnimationPlayer from '@site/src/components/AnimationPlayer';
import ApiSnippet from '@site/src/components/Api/ApiSnippet';

# Layouts

<AnimationPlayer name="layout" banner />

Layouts allow you to arrange your nodes using [Flexbox][flexbox]. Any node
extending the [`Layout`](/api/2d/components/Layout) node can become a part of
the layout. This includes, but is not limited to:
[`Rect`](/api/2d/components/Rect), [`Circle`](/api/2d/components/Circle), and
[`Img`](/api/2d/components/Img).

## Layout root

Layouts are an opt-in feature, meaning that they need to be enabled. It's done
by setting the [`layout`](/api/2d/components/Layout#layout) property on the Node
that we want to become the root of our layout:

```tsx
// ↓ layout root
<Rect layout>
  {/* ↓ layout child */}
  <Circle width={320} height={320} />
</Rect>
```

In the example above, we marked the `<Rect>` as the layout root. This will cause
the position and size of its descendants to be controlled by Flexbox (In this
case there's only one valid descendant: `<Circle>`). The layout root itself is
treated differently than its children - its size is controlled by Flexbox, but
the position stays unaffected.

:::info

Just setting the `layout` property doesn't always turn the node into a layout
root. If the node is already a part of the layout, it will be treated like the
rest of the descendants:

```tsx
// ↓ layout root
<Rect layout>
  {/* ↓ layout child, NOT a layout root */}
  <Rect layout>
    {/* ↓ layout child */}
    <Circle width={320} height={320} />
  </Rect>
</Rect>
```

:::

## Size and offset

Aside from the position, rotation, and scale, any node extending the `Layout`
class has additional `size` and `offset` properties:

### `Layout.size`

<ApiSnippet url={'/api/2d/components/Layout#size'} />
<hr />

### `Layout.offset`

<ApiSnippet url={'/api/2d/components/Layout#offset'} />
<hr />

## Flexbox configuration

Most flexbox attributes available in CSS are available as
[`Layout` properties](/api/2d/components/Layout#Properties). You can check out
this [Flexbox guide][flexbox] to better understand how they work. The most
useful properties are listed below:

### `Layout.padding`

<ApiSnippet url={'/api/2d/components/Layout#padding'} />
<hr />

### `Layout.margin`

<ApiSnippet url={'/api/2d/components/Layout#margin'} />
<hr />

### `Layout.gap`

<ApiSnippet url={'/api/2d/components/Layout#gap'} />
<hr />

### `Layout.direction`

<ApiSnippet url={'/api/2d/components/Layout#direction'} />
<hr />

### `Layout.alignItems`

<ApiSnippet url={'/api/2d/components/Layout#alignItems'} />
<hr />

### `Layout.justifyContent`

<ApiSnippet url={'/api/2d/components/Layout#justifyContent'} />
<hr />

### Disabling `layout` on a child node

Sometimes it can be useful to remove the node from the node tree. This way the
node can be styled independently of its ancestor layout, as well as moved freely
on the canvas.

Removal of node from the node tree is done by setting a value of `layout`
property to `false`. The node can be brought back to its original position
inside the node tree by setting the value of `layout` property to `true`.

After disabling `layout` on a node, the following things change:

1. the node is moved to the place of origin, e.g. center of the scene,
2. the node can now be position on canvas freely,
3. the node no longer inherits properties from its parent, such as text styling,
4. the node's former parent layout will no longer considers the node's width or
   height when calculating its own bounding box. Disabling a layout on a node
   can be roughly thought of as an equivalent to setting a `position` CSS
   property of an HTML node to `absolute` value.

:::info

The node retains its rendering order (`z-index`, in terms of CSS), e.g. it will
potentially overlap any other nodes that were rendered previously, as well as
get potentially covered by nodes that appear later.

:::

Consider the following example:

1. a top-level `<Rect>` node has a `layout` property set, meaning that all its
   children nodes follow `<Rect>`'s styling and direction,
2. the yellow `<Circle>` is a child of `<Rect>`,
3. commenting out line `yellowCircle().layout = false;` will make two green
   circles get close to each other, as if the yellow circle is not there; the
   yellow circle now stands alone now, can be moved freely and has it's own text
   styling.

```tsx editor
import {makeScene2D} from '@motion-canvas/2d/lib/scenes';
import {Circle, Rect} from '@motion-canvas/2d/lib/components';
import {createRef} from '@motion-canvas/core/lib/utils';

export default makeScene2D(function* (view) {
  const yellowCircle = createRef<Circle>();

  view.add(
    <Rect layout alignItems="center" direction="row">
      <Circle width={100} height={100} fill="forestgreen" />
      <Circle width={150} height={150} fill="yellow" ref={yellowCircle} />
      <Circle width={100} height={100} fill="green" />
      <Circle width={100} height={100} fill="darkgreen" />
    </Rect>,
  );

  yellowCircle().layout = false;
});
```

## Groups

Nodes that don't extend the `Layout` class, such as the `Node` itself, are
unaffected by the layout and are treated as if they were never there. This lets
you apply filters and transformations to layout nodes without affecting the
hierarchy.

From the layout's perspective, all `<Rect>`s in the example below are siblings:

```tsx
<Layout direction={'column'} width={960} gap={40} layout>
  <Node opacity={0.1}>
    <Rect height={240} fill={'#ff6470'} />
    <Rect height={240} fill={'#ff6470'} />
  </Node>
  <Rect height={240} fill={'#ff6470'} />
</Layout>
```

<AnimationPlayer name="layout-group" small />

[flexbox]: https://css-tricks.com/snippets/css/a-guide-to-flexbox/
